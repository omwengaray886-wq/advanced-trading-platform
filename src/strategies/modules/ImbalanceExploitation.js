import { StrategyBase } from '../StrategyBase.js';
import { EntryZone } from '../../models/annotations/EntryZone.js';
import { TargetProjection } from '../../models/annotations/TargetProjection.js';
import { ImbalanceDetector } from '../../analysis/imbalanceDetector.js';

/**
 * Imbalance Exploitation Strategy
 * 
 * Trades specifically off Fair Value Gaps (FVG) and Volume Imbalances
 * with multi-timeframe confirmation.
 */
export class ImbalanceExploitation extends StrategyBase {
    constructor() {
        super(
            'Imbalance Exploitation',
            'Precision entries inside Fair Value Gaps (FVG) targeting rebalancing.'
        );
    }

    evaluate(marketState, direction = 'LONG') {
        // Need FVGs
        const fvgs = marketState.fvgs || [];
        if (fvgs.length === 0) return 0;

        // Find relevant FVG
        // For LONG, we need a Demand FVG (Bullish FVG) below current price (or we are in it)
        // For SHORT, we need a Supply FVG (Bearish FVG) above current price (or we are in it)

        const relevantFVG = fvgs.find(fvg => {
            if (direction === 'LONG') {
                return fvg.type === 'BULLISH' && marketState.currentPrice >= fvg.bottom; // We can be above or inside
            } else {
                return fvg.type === 'BEARISH' && marketState.currentPrice <= fvg.top; // We can be below or inside
            }
        });

        if (!relevantFVG) return 0.2;

        // Score based on trend alignment
        const trend = marketState.trend.direction;
        let score = 0.6;

        const isAligned = (direction === 'LONG' && trend === 'BULLISH') || (direction === 'SHORT' && trend === 'BEARISH');
        if (isAligned) score = 0.85;

        return score;
    }

    generateAnnotations(candles, marketState, direction = 'LONG') {
        const annotations = [];
        const fvgs = marketState.fvgs || [];

        // Find the 'active' FVG we are trading
        // Ideally the one closest to price that supports our direction
        const relevantFVGs = fvgs.filter(fvg =>
            (direction === 'LONG' && fvg.type === 'BULLISH') ||
            (direction === 'SHORT' && fvg.type === 'BEARISH')
        ).sort((a, b) => {
            // Sort by proximity to current price
            return Math.abs(a.price - marketState.currentPrice) - Math.abs(b.price - marketState.currentPrice);
        });

        const targetFVG = relevantFVGs[0];
        if (!targetFVG) return [];

        // Logic: 
        // Entry at the "Open" of the FVG (the start of the gap)
        // Or at the 50% consequent encroachment (CE)

        // Bullish FVG: Top is the entry (retrace down to it), CE is better entry.
        // Bearish FVG: Bottom is the entry (retrace up to it), CE is better entry.

        const entryLevel = direction === 'LONG' ? targetFVG.top : targetFVG.bottom;
        const ceLevel = (targetFVG.top + targetFVG.bottom) / 2;

        annotations.push(new EntryZone(
            entryLevel,
            ceLevel,
            direction === 'LONG' ? 'LONG' : 'SHORT',
            {
                id: `fvg-${targetFVG.timestamp}`,
                note: 'FVG Fill Entry',
                confidence: 0.85
            }
        ));

        // Stop Loss: Just beyond the FVG candle (the creation candle)
        // Or simpler: beyond the FVG limits
        const stop = direction === 'LONG' ? targetFVG.bottom : targetFVG.top;
        annotations.push(new TargetProjection(stop, 'STOP_LOSS', { label: 'Gap Invalidation' }));

        // Targets
        const targets = this.generateStandardTargets(entryLevel, stop, marketState.liquidityPools, direction);
        targets.forEach((t, i) => {
            annotations.push(new TargetProjection(t.price, `TARGET_${i + 1}`, { label: t.label, riskReward: t.riskReward }));
        });

        return annotations;
    }

    getEntryLogic(analysis) {
        return 'Price rebalancing inefficient delivery (Fair Value Gap).';
    }

    getInvalidationLogic(analysis) { return ''; }
    getRiskParameters(analysis) { return {}; }
}
